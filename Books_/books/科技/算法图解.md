# 函数式编程、Git、机器学习和并发

算法图解 by [美] Aditya Bhargava (z-lib.org).pdf

# 二分查找;
还将学习使用大O表示法分析算法的速度。本书从始至终都将使用大O表示法来分析算法的速度
## 用二分查找最多需要log2n步，而简单查找最多需要n步。
因为log 1024 = 10(2 10 =1024)。
### 可汗学院
https://www.khanacademy.org/math/algebra-home/alg-exp-and-log/alg-logarithmic-equations/v/solving-logarithmic-equations
仅当列表是有序的时候，二分查找才管用。例如，电话簿中的名字是按字母顺序排列的， 因此可以使用二分查找来查找名字。如果名字不是按顺序排列的，结果将如何呢?
```
def binary_search(list, item):
  # low and high keep track of which part of the list you'll search in.
  low = 0
  high = len(list) - 1

  # While you haven't narrowed it down to one element ...
  while low <= high:
    # ... check the middle element
    mid = (low + high) // 2
    guess = list[mid]
    # Found the item.
    if guess == item:
      return mid
    # The guess was too high.
    if guess > item:
      high = mid - 1
    # The guess was too low.
    else:
      low = mid + 1

  # Item doesn't exist
  return None

my_list = [1, 3, 5, 7, 9]
a = binary_search(my_list, 3)  # => 1
print(a)
```
## 这被称为线性 时间(linear time)。  o(n)
最多需要猜测的次数与列表长度相同

# 二分查找的运行时间为对数时间(或log时间) o(log n)
如果列表包含100个元素，最多要猜7次;如果列表包含40亿个数字，最多 需猜32次。厉害吧?
列表包含10亿个元素时，为3300万倍。有鉴于此，仅知道算法 需要多长时间才能运行完毕还不够，还需知道运行时间如何随列表增长 而增加。这正是大O表示法的用武之地。
# 算法的速度指的并非时间，而是操作数的增速。
O(n * log n)，这样的算法包括第4章将介绍的快速排序——一种速度较快的排序算法。 
 O(n2)，这样的算法包括第2章将介绍的选择排序——一种速度较慢的排序算法。
 O(n!)，这样的算法包括接下来将介绍的旅行商问题的解决方案——一种非常慢的算法。

# 数组
内存中都是相连的(紧靠在 一起的)。
但原来坐的地方没有空位置， 只得再找一个可坐下所有人的地方。在这种情况下，你需要请求计算机重新分配一块可容纳4个 待办事项的内存，再将所有待办事项都移到那里。
## 需要随机地读取元素时，数组的效率很高，因为可迅 速找到数组的任何元素。
在链表中，元素并非靠在一起的，你无法迅速计算出第五个元素的内存 地址，而必须先访问第一个元素以获取第二个元素的地址，再访问第二个元素以获取第三个元素 的地址，以此类推，直到访问第五个元素。
### 元素的位置称为索引。因此，不说“元素20的位置为1”，而说“元素20位于索引1处”。本书 将使用索引来表示位置。
# 链表
## 链表中的元素可存储在内存的任何地方。
这犹如寻宝游戏。你前往第一个地址，那里有一张纸条写着“下一个元素的地址为123”。因 此，你前往地址123，那里又有一张纸条，写着“下一个元素的地址为847”，以此类推。在链表 中添加元素很容易:只需将其放入内存，并将其地址存储到前一个元素中。

### 如果你要删除元素呢?链表也是更好的选择，因为只需修改前一个元素指向的地址即可。而
 使用数组时，删除元素后，必须将后面的元素都向前移
 
 因为它支持随机访问。有两 种访问方式:随机访问和顺序访问。顺序访问意味着从第一个元素开始逐个地读取元素。链表只 能顺序访问:要读取链表的第十个元素，得先读取前九个元素，并沿链接找到第十个元素。随机 10 访问意味着可直接跳到第十个元素。

### 链表的优势在插入元素方面
需要跳跃，链表的效率 真的很低。

### 混合数据: 数组 + 链表

# 第二种算法——选择排序
列出对乐队进行排序的代码，但下述代码提供了类似的功能
```rub
# Finds the smallest value in an array
def findSmallest(arr):
  # Stores the smallest value
  smallest = arr[0]
  # Stores the index of the smallest value
  smallest_index = 0
  for i in range(1, len(arr)):
    if arr[i] < smallest:
      smallest = arr[i]
      smallest_index = i
  return smallest_index

# Sort array
def selectionSort(arr):
  newArr = []
  for i in range(len(arr)):
      # Finds the smallest element in the array and adds it to the new array
      smallest = findSmallest(arr)
      newArr.append(arr.pop(smallest))
  return newArr

print( selectionSort([5, 3, 6, 2, 10]))
```

# 递归
# 数据结构称为栈。栈是一种简单的数据结构 （call stack 调入栈）
push pop

# 快速排序 时间为O(n log n)
每个递归函数都有两部分:基线 条件(base case)和递归条件(recursive case)。

 递归指的是调用自己的函数。
 每个递归函数都有两个条件:基线条件和递归条件。  栈有两种操作:压入和弹出。
 所有函数调用都进入调用栈。
 调用栈可能很长，这将占用大量的内存。

分而治之(divide and conquer，D&C)——一种著名的递归式问题解决方法。
```
诸如Haskell等函数式编程语言没有循环，因此你只能使用递归来编写这样的函数。 如果你对递归有深入的认识，函数式编程语言学习起来将更容易。例如，使用Haskell时，你可 能这样编写函数sum。
sum [] = 0
sum (x:xs) = x + (sum xs)
基线条件 递归条件
  注意，这就像是你有函数的两个定义。符合基线条件时运行第一个定义，符合递归条件时 运行第二个定义。也可以使用Haskell语言中的if语句来编写这个函数。
    sum arr = if arr == []
                then 0
                else (head arr) + (sum (tail arr))
但前一个版本更容易理解。Haskell大量使用了递归，因此它提供了各种方便实现递归的语 法。如果你喜欢递归或想学习一门新语言，可以研究一下Haskell。
```

# 二叉树 ??

# 数据结构——数组和链表


# 散列表是一种很有用的数据结构，由键值对组成
