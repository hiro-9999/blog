# 函数式编程、Git、机器学习和并发

算法图解 by [美] Aditya Bhargava (z-lib.org).pdf

# 二分查找;
还将学习使用大O表示法分析算法的速度。本书从始至终都将使用大O表示法来分析算法的速度
## 用二分查找最多需要log2n步，而简单查找最多需要n步。
因为log 1024 = 10(2 10 =1024)。
### 可汗学院
https://www.khanacademy.org/math/algebra-home/alg-exp-and-log/alg-logarithmic-equations/v/solving-logarithmic-equations
仅当列表是有序的时候，二分查找才管用。例如，电话簿中的名字是按字母顺序排列的， 因此可以使用二分查找来查找名字。如果名字不是按顺序排列的，结果将如何呢?
```
def binary_search(list, item):
  # low and high keep track of which part of the list you'll search in.
  low = 0
  high = len(list) - 1

  # While you haven't narrowed it down to one element ...
  while low <= high:
    # ... check the middle element
    mid = (low + high) // 2
    guess = list[mid]
    # Found the item.
    if guess == item:
      return mid
    # The guess was too high.
    if guess > item:
      high = mid - 1
    # The guess was too low.
    else:
      low = mid + 1

  # Item doesn't exist
  return None

my_list = [1, 3, 5, 7, 9]
a = binary_search(my_list, 3)  # => 1
print(a)
```
## 这被称为线性 时间(linear time)。  o(n)
最多需要猜测的次数与列表长度相同

# 二分查找的运行时间为对数时间(或log时间) o(log n)
如果列表包含100个元素，最多要猜7次;如果列表包含40亿个数字，最多 需猜32次。厉害吧?
列表包含10亿个元素时，为3300万倍。有鉴于此，仅知道算法 需要多长时间才能运行完毕还不够，还需知道运行时间如何随列表增长 而增加。这正是大O表示法的用武之地。
# 算法的速度指的并非时间，而是操作数的增速。
O(n * log n)，这样的算法包括第4章将介绍的快速排序——一种速度较快的排序算法。 
 O(n2)，这样的算法包括第2章将介绍的选择排序——一种速度较慢的排序算法。
 O(n!)，这样的算法包括接下来将介绍的旅行商问题的解决方案——一种非常慢的算法。

# 数组
内存中都是相连的(紧靠在 一起的)。
但原来坐的地方没有空位置， 只得再找一个可坐下所有人的地方。在这种情况下，你需要请求计算机重新分配一块可容纳4个 待办事项的内存，再将所有待办事项都移到那里。
## 需要随机地读取元素时，数组的效率很高，因为可迅 速找到数组的任何元素。
在链表中，元素并非靠在一起的，你无法迅速计算出第五个元素的内存 地址，而必须先访问第一个元素以获取第二个元素的地址，再访问第二个元素以获取第三个元素 的地址，以此类推，直到访问第五个元素。
### 元素的位置称为索引。因此，不说“元素20的位置为1”，而说“元素20位于索引1处”。本书 将使用索引来表示位置。
# 链表
## 链表中的元素可存储在内存的任何地方。
这犹如寻宝游戏。你前往第一个地址，那里有一张纸条写着“下一个元素的地址为123”。因 此，你前往地址123，那里又有一张纸条，写着“下一个元素的地址为847”，以此类推。在链表 中添加元素很容易:只需将其放入内存，并将其地址存储到前一个元素中。

### 如果你要删除元素呢?链表也是更好的选择，因为只需修改前一个元素指向的地址即可。而
 使用数组时，删除元素后，必须将后面的元素都向前移
 
 因为它支持随机访问。有两 种访问方式:随机访问和顺序访问。顺序访问意味着从第一个元素开始逐个地读取元素。链表只 能顺序访问:要读取链表的第十个元素，得先读取前九个元素，并沿链接找到第十个元素。随机 10 访问意味着可直接跳到第十个元素。

### 链表的优势在插入元素方面
需要跳跃，链表的效率 真的很低。

### 混合数据: 数组 + 链表

# 第二种算法——选择排序
快速排序 时间为O(n log n)
# 
# 二叉树 ??

# 数据结构——数组和链表

# 递归

# 散列表是一种很有用的数据结构，由键值对组成
