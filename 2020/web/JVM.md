JVM = 类加载器(classloader) + 执行引擎(execution engine) + 运行时数据区域(runtime data area)

https://www.toutiao.com/a6778366212142268931/


>栈的限制

一个栈可以是动态的或者是有合适大小的。如果一个线程要求更大的栈，那么将抛出StackOverflowError异常；如果一个线程要求新创建一个frame，又没有足够的内存空间来分配，将会抛出OutOfMemoryError异常。

>堆

堆中某个节点的值总是不大于或不小于其父节点的值；
堆总是一棵完全二叉树。


>非堆式的内存包括：

永久代中包含：
方法区
内部字符串
代码缓存：用于编译以及存储方法，这些方法已经被JIT编译成本地代码


>堆（Heap）与栈（Stack）
1）程序内存布局场景下，堆与栈表示两种内存管理方式；
2）数据结构场景下，堆与栈表示两种常用的数据结构。
堆的效率比栈要低得多。

>栈（Stack）
栈由操作系统自动分配释放 ，用于存放函数的参数值、局部变量等，
栈中存储的数据的生命周期随着函数的执行完成而结束。

>堆
堆由开发人员分配和释放， 若开发人员不释放，程序结束时由 OS 回收，分配方式类似于链表。
https://blog.csdn.net/K346K346/article/details/80849966
关于堆上内存空间的分配过程，首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆节点，然后将该节点从空闲节点链表中删除，并将该节点的空间分配给程序。另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确地释放本内存空间。由于找到的堆节点的大小不一定正好等于申请的大小，系统会自动地将多余的那部分重新放入空闲链表。
